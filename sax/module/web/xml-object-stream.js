var events, expat, stripNamespace;

expat = require('node-expat');

events = require('events');

// fucking bytes cleanup!!! yep! Albert 1 oct 2015
var r_cleanup = /[\u0000-\u0008\u000b-\u000c\u000e-\u001f\u007f-\u009f]+/g;
var err_count = 0;

exports.parse = function(readStream, options) {
  var each, emitter, parser;

  !options && (options = {});

  if (options.stripNamespaces == null) {
    options.stripNamespaces = true;
  }

  // Albert - oct 2015
  // bytes_cleanup is false by default
  if ( options['bytes_cleanup'] == null ) {
    options['bytes_cleanup'] = false;
  }

  parser = new expat.Parser("UTF-8");
  emitter = new events.EventEmitter();

  readStream.on ('data', function(data) {

    // if bytes cleanup should be made - it should be made BEFORE attempting parse
    // else it doesn't work - tested
    options['bytes_cleanup'] && (data = data.toString().replace(r_cleanup, ''));
    var ret = parser.parse(data.toString());

    // !ret && ++err_count && console.log(parser.getError(), data.toString());
    !ret && ++err_count;
    return ret;
  });

  readStream.on('end', function() {
    return process.nextTick(function() {
      // console.log('errors:',err_count);
      return emitter.emit('end');
    });
  });

  readStream.on('error', function(err) {
    return emitter.emit('error', err);
  });

  readStream.on('close', function() {
    return emitter.emit('close');
  });

  each = function(nodeName, eachNode) {
    var currentNode, eachNodeDelayed;
    eachNodeDelayed = function(node) {
      return process.nextTick(function() {
        return eachNode(node);
      });
    };
    currentNode = null;
    parser.on('error', function(err) {
      // console.log(err);
      return emitter.emit('error', err);
    });
    parser.on('startElement', function(name, attrs) {
      if (options.stripNamespaces) {
        name = stripNamespace(name);
      }
      if (name === nodeName || currentNode) {
        return currentNode = {
          $name: name,
          $: attrs,
          $parent: currentNode
        };
      }
    });
    parser.on('text', function(text) {
      if (currentNode == null) {
        return;
      }
      if (currentNode.$text == null) {
        currentNode.$text = "";
      }
      return currentNode.$text += text;
    });
    return parser.on('endElement', function(name) {
      var parent;
      if (currentNode == null) {
        return;
      }
      if (currentNode.$name === nodeName) {
        if (currentNode.$parent) {
          throw new Error("Top-level node should not have a parent. Possible memory leak");
        }
        eachNodeDelayed(currentNode);
      }
      parent = currentNode.$parent;
      if (parent != null) {
        delete currentNode.$parent;
        if (parent.$children == null) {
          parent.$children = [];
        }
        parent.$children.push(currentNode);
        parent[currentNode.$name] = currentNode;
      }
      return currentNode = parent;
    });
  };

  return {
    each: each,
    on: function(e, cb) {
      return emitter.on(e, cb);
    },
    pause: function() {
      return readStream.pause();
    },
    resume: function() {
      return readStream.resume();
    }
  };
};

stripNamespace = function(name) {
  return name.replace(/^.*:/, "");
};

// ---
// generated by coffee-script 1.9.2
